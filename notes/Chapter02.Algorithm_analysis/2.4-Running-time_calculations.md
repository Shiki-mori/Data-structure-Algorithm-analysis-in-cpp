# 2.4 运行时间计算
为简化算法分析，我们约定不存在特定的时间单位，将忽略常数和低阶项。 
## 2.4.1 一个简单的例子
*学习效率太过低下，从现在开始必须改变*  
## 2.4.2 一般法则  
1. for循环  
for循环的运行时间至多是该for循环内部那些语句的运行时间乘以迭代次数  
2. 嵌套的循环  
从里向外分析循环。一组嵌套循环内部的一条语句总的运行时间为该语句的运行时间乘以该组所有for循环大小的乘积。  
例如：
    ```cpp
    for (i = 0; i < n; i++)
      for (j = 0; j < n; j++)
        k++;
    ```
    该片段为O(N^2)。
3. 顺序语句  
求和，取其中最大值  
4. if/else语句  
判断运行时间 + 分支中运行时间长者的运行时间  

分析的基本策略是从最内部向外展开分析。  

如果有函数调用，需要先分析调用。  
如果有递归函数，则：  
- 若递归可转换为简单的循环结构，则分析很容易；
- 递归很难被转换成简单循环。分析将涉及求解一个递推关系。  

一个计算斐波那契数列的递归函数：  
```cpp
// fib
int fib(int n) {
  if (n <= 1)
    return 1;
  else
    return fib(n - 1) + fib(n - 2);
}
```
实际上这段程序违反了递归的合成效益法则，导致极低的运行效率。T(N)=0.618^N  
## 2.4.3 最大子序列和问题的求解
接下来将给出4个求解最大子序列和问题的算法。  
*2026/1/16 16:43*  
算法1：穷举  
```cpp
// 2.5 Algorithm 1
int maxSubSum1(const vector<int> &a) {
  int maxSum = 0;
  for (int i = 0; i < a.size(); i++) {
    for (int j = i; j < a.size(); j++) {
      int thisSum = 0;
      for (int k = i; k <= j; k++)
        thisSum += a[k];

      if (thisSum > maxSum)
        maxSum = thisSum;
    }
  }
  return maxSum;
}
```
第一个循环大小为N，第二个循环大小为N-i，第三个循环大小为j-i(+1)。  
需要假设最坏的情况，则N-i为N，j-i(+1)为N。  
则总数为O(N^3)。  

算法2：
```cpp
// 2.6 Algorithm 2
int maxSubSum2(const vector<int> &a) {
  int maxSum = 0;
  for (int i = 0; i < a.size(); i++) {
    int thisSum = 0;
    for (int j = i; j < a.size(); j++) {
      thisSum += a[j];
      if (thisSum > maxSum)
        maxSum = thisSum;
    }
  }
  return maxSum;
}
```
O(N^2)  

算法3：递归  
分治（divide-and-conquer）  
分：把问题分成两个大致相等的子问题，然后递归地求解子问题  
治：将两个子问题的解合并，做一些附加工作得到整个问题的解  
