# 2.4 运行时间计算
为简化算法分析，我们约定不存在特定的时间单位，将忽略常数和低阶项。 
## 2.4.1 一个简单的例子
*学习效率太过低下，从现在开始必须改变*  
## 2.4.2 一般法则  
1. for循环  
for循环的运行时间至多是该for循环内部那些语句的运行时间乘以迭代次数  
2. 嵌套的循环  
从里向外分析循环。一组嵌套循环内部的一条语句总的运行时间为该语句的运行时间乘以该组所有for循环大小的乘积。  
例如：
    ```cpp
    for (i = 0; i < n; i++)
      for (j = 0; j < n; j++)
        k++;
    ```
    该片段为O(N^2)。
3. 顺序语句  
求和，取其中最大值  
4. if/else语句  
判断运行时间 + 分支中运行时间长者的运行时间  

分析的基本策略是从最内部向外展开分析。  

如果有函数调用，需要先分析调用。  
如果有递归函数，则：  
- 若递归可转换为简单的循环结构，则分析很容易；
- 递归很难被转换成简单循环。分析将涉及求解一个递推关系。  

一个计算斐波那契数列的递归函数：  
```cpp
// fib
int fib(int n) {
  if (n <= 1)
    return 1;
  else
    return fib(n - 1) + fib(n - 2);
}
```
实际上这段程序违反了递归的合成效益法则，导致极低的运行效率。T(N)=0.618^N  
## 2.4.3 最大子序列和问题的求解
接下来将给出4个求解最大子序列和问题的算法。  
*2026/1/16 16:43*  
算法1：穷举  
```cpp
// 2.5 Algorithm 1
int maxSubSum1(const vector<int> &a) {
  int maxSum = 0;
  for (int i = 0; i < a.size(); i++) {
    for (int j = i; j < a.size(); j++) {
      int thisSum = 0;
      for (int k = i; k <= j; k++)
        thisSum += a[k];

      if (thisSum > maxSum)
        maxSum = thisSum;
    }
  }
  return maxSum;
}
```
第一个循环大小为N，第二个循环大小为N-i，第三个循环大小为j-i(+1)。  
需要假设最坏的情况，则N-i为N，j-i(+1)为N。  
则总数为O(N^3)。  

算法2：
```cpp
// 2.6 Algorithm 2
int maxSubSum2(const vector<int> &a) {
  int maxSum = 0;
  for (int i = 0; i < a.size(); i++) {
    int thisSum = 0;
    for (int j = i; j < a.size(); j++) {
      thisSum += a[j];
      if (thisSum > maxSum)
        maxSum = thisSum;
    }
  }
  return maxSum;
}
```
O(N^2)  

算法3：递归  
分治（divide-and-conquer）  
分：把问题分成两个大致相等的子问题，然后递归地求解子问题  
治：将两个子问题的解合并，做一些附加工作得到整个问题的解  

给定一个数组，将其分为前后两半。最大子序列可能出现在前半，后半，或者中间部分。  
对于前半和后半，可递归解决。  
对于中间部分求最大子序列，方法是将前半包括最后一个元素的最大子序列和加上后半包括第一个元素的最大子序列和。  
比较三种方式得到的最大子序列，取最大值。  
```cpp
// 2.7 Algorithm 3
int max3(int num1, int num2, int num3) {
  int temp = num1 > num2 ? num1 : num2;
  return temp > num3 ? temp : num3;
}
int maxSubSum3(const vector<int> &a, int left, int right) {
  // 基准情形
  if (left == right) {
    if (a[left] > 0)
      return a[left];
    else
      return 0;
  }

  int center = (left + right) / 2;
  int leftMaxSum = maxSubSum3(a, left, center);
  int rightMaxSum = maxSubSum3(a, center + 1, right);
  // cout << "center = " << center << endl;
  int leftMaxSumBoard = 0; // 左半部分带最后一个元素的最大子序列和
  int leftSum = 0;         // 左半部分子序列和
  for (int i = center; i >= left; i--) {
    leftSum += a[i];
    // cout << "i = " << i << ' ' << "leftMaxSumBoard = " << leftMaxSumBoard<<
    // endl;
    if (leftMaxSumBoard < leftSum)
      leftMaxSumBoard = leftSum;
  }
  int rightMaxSumBoard = 0; // 右半部分带最后一个元素的最大子序列和
  int rightSum = 0;         // 右半部分子序列和
  for (int j = center + 1; j <= right; j++) {
    rightSum += a[j];
    if (rightMaxSumBoard < rightSum)
      rightMaxSumBoard = rightSum;
  }
  // cout << leftMaxSumBoard << ' ' << rightMaxSumBoard << endl;
  // return 0;
  return max3(leftMaxSum, rightMaxSum, leftMaxSumBoard + rightMaxSumBoard);
}
```
*我的天哪，真是绝妙的方法！*   
分析该算法的时间复杂度。  
设对于问题规模N的时间耗费为T(N)。  
N = 1, T(N) = 1.  
N > 1, T(N) = 2*T(N/2) + O(N). 其中2\*T(N/2) 为两次递归消耗，O(N)为for循环消耗。  
计算时可用N代替O(N)。严格解方程将在第7章出现。这里我们注意到：  
T(2^k) = 2^k * (k+1).  
易得T(N) = O(NlogN).  

算法4：基础动态规划  
如果a[i]是负值，那么a[i]一定不是最大子序列的起点；  
如果i到j的序列和是负值，那么这段序列一定不是最大子序列的前缀。  
当发现i到j的子序列和为负值时，直接跳过该段，即从i跳到j+1。  
理由：  
在i到j之间任取两个值p\<q，则从p到q的序列和一定不大于i到q的序列和。所以从p到j的所有序列都不可能是最优序列。    
如果i~p为最大序列，那么这个序列和已经在i到j的循环中被记录下来了，我们继续向后遍历，依旧会跳过到j+1。  *以上这句话是我初次遇到该算法时想不明白写下来的。*  
```cpp
// 2.8 Algorithm 4
int maxSubSum4(const vector<int> &a) {
  int sum = 0;
  int maxSum = 0;
  for (int i = 0; i < a.size(); i++) {
    sum += a[i];
    if (sum < 0)
      sum = 0;
    if (maxSum < sum)
      maxSum = sum;
  }
  return maxSum;
}
```
算法的联机特性（on-line algorithm）：在任意时刻，算法都能对已读入的数据给出子序列问题的答案。其他三个算法不具备这样的特性。仅需要常量空间并以线性时间运行的联机算法几乎是完美的。

*2026/1/17 01:30*
## 2.4.4 对数时间复杂度
常见的是，某些分治算法的时间复杂度为O(NlogN)。  
此外，对数出现的规律为：  
一个算法以常数时间O(1)将问题规模削减为其中一部分（通常是1/2），则时间复杂度为O(logN)。若以常数时间将问题削减一个常数（如将问题N削减为N-1），则时间复杂度为O(N)。  
讨论这类算法通常忽略其输入问题时产生的时间耗费。  

下面介绍三种具有对数特点的算法。  
1. 折半查找（binary search）  
    >给定一个整数X，一个有序数列A_0, A_1, ... , A_(N-1)。求下标i使得X = A_i。若查找失败，返回 i = -1 。  
    ```cpp
    // 2.9 binary search
    template <typename Comparable>
    int binarySearch(const vector<Comparable> &a, const Comparable &x) {
      size_t left = 0;
      size_t right = a.size() - 1;

      while (left <= right) {
        size_t mid = (left + right) / 2;
        if (x == a[mid]) {
          // cout << "x==a[mid]" << endl;
          return mid;
        } else if (x < a[mid])
          right = mid - 1;
        else
          left = mid + 1;
      }
      return -1;
    }
    ```
    循环从 high-low = N 开始，到 high-low = 0 结束。每次迭代，high-low 的值都减为上一次的1/2。设迭代次数为x，则 (1/2)^x = -N，得 x = log N。  
    该算法的时间复杂度为O(logN)。

2. 欧几里得算法  
    >计算最大公因数。两个整数的最大公因数 gcd 是同时整除二者的最大整数。  
    算法连续计算余数，直到余数为0。最后的非零余数即为最大公因数。  

    定理：若M>N，则M mod N < M/2  
    证明：若N <= M/2，余数一定小于N，不等式成立；若N > M/2，余数一定为M-N < M/2，不等式成立。  
    可以推出，两次迭代后，余数最多为原始值的一半。（很容易推出）  
    则迭代次数最多为2logN = O(logN)。  

*2026/1/17 15:27*
3. 幂运算  
