# 2.1 数学基础
在函数之间建立一种相对的级别。我们比较它们的**相对增长率**（relative rates of growth）。  
>T(N) = O(f(N)):T(N) <= cf(N)  
T(N) = Ω(g(N)):T(N) >= cg(N)  
T(N) = Θ(h(N)):T(N) = O(h(N)), T(N) = Ω(h(N))  
T(N) = o(p(N)):T(N) < cp(N)   

T(N) = O(f(N))时，保证函数T(N)的增长率小于等于f(N)，因此f(N)是T(N)的一个上界（upper bound）。这同时说明f(N) = Ω(T(N))，即T(N)是f(N)的一个下界（lower bound）。  

举例：  
N^2 = O(N^3), N^3 = Ω(N^2);  
2N = Θ(N).  

几个重要结论：  
>法则1：  
若T1(N) = O(f(N)), T2(N) = O(g(N)),  
则T1(N) + T2(N) = O(f(N) + g(N)), 可直接写为O(max(f(N), g(N)));  
T1(N) * T2(N) = O(f(N) * g(N))  
法则2：  
若T(N)是k次多项式，则T(N) = Θ(N^k)  
法则3：  
对任意常数k， log^k N = O(N)。（对数的k次幂）这说明对数增长非常缓慢。

有几点需要注意。  
- 不要将常数或低阶项放进大O。  
即T(N) = O(2N^2) 或 T(N) = O(N^2 + N) 的正确形式应为 T(N) = O(N^2) 。  
在需要大O表示的任何分析结果中，低阶项和常数因子一般都可忽略，要求的精度很粗。  
- 总能通过计算极限 lim(N->∞)f(N)/g(N)来确定f(N)和g(N)的相对增长率。  
这样几乎总能足以算出相对增长率。但过于复杂。通常简单的代数方法就足够了。