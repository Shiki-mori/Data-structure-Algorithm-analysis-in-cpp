# 3.3 STL中的vector和list
C++在库中包含一些常用数据结构的实现。这部分称为标准模板库（Standard template library，STL）。这些数据结构称为容器（container）或集合（collection）。  
listADT包含在其中。  

*2026/1/17 18:29*

表ADT有两种流行的实现方法。  
vector提供可增长的数组实现；  
list提供双向链表实现。   

vector和list都是类模板。它们有一些方法是共有的。  
以下三种方法适用于所有STL容器：  
- int size() const  
返回容器中元素个数  
- void clear()  
删除容器中的所有元素  
- bool empty() const  
判断容器是否为空  

vector和list支持以常数时间对表的尾端进行添加和删除操作，以常数时间访问表头项。  
- void push_back(const Object &x)  
把x添加到表尾  
- void pop_back()  
删除表尾对象  
- const Object &back() const  
返回表尾对象，还有返回引用的修改函数版本  
- const Object &front() const  
返回表头对象，还有返回引用的修改函数版本  

双向链表list可在表头进行高效改动，vector则不能。以下方法仅对list适用：  
- void push_front(const Object &x)  
把x添加到表头  
- void pop_front()  
删除表头对象  

vector可进行高效的索引操作，查看和改变指定位置的对象，list则不能。以下方法仅对vector适用：  
- Object &operator[](int idx)  
返回vector中下标为idx的对象，不带界限检验，还有返回常量引用的访问函数版本  
- Object &at(int idx)  
返回vector中下标为idx的对象，带有界限检验，还有返回常量引用的访问函数版本  
- int capacity() const  
返回vector的内部容量（参见3.4）  
- void reserve(int newCapacity)  
设置新的容量。可以使用好的估计来避免扩展vector（参见3.4）  
## 3.3.1 迭代器iterator  
对表的一些操作需要位置。STL中，位置由内嵌类型 iterator 表示。对于:  
list<string\>, 位置：list<string\>::iterator  
vector<int\>, 位置：vector<int\>::iterator  
在描述时直接使用iterator作为简记。编写代码时使用具体的类名。  

存在三个问题：
1. **获取迭代器iterator**  
    STL容器定义了一对方法：  
    - iterator begin()  
    返回一个适当的迭代器，表示容器中的第一项。  
    - iterator end()  
    返回一个适当的迭代器，表示容器尾端标记（endmarker），即容器中最后一项之后的位置。  

    end方法返回一个“越界”的迭代器。  
    考虑不使用范围for循环时打印vector v中的项：  
    ```cpp 
    for (int i = 0; i != v.size(); i++)
    cout << v[i] << endl;
    ```
    使用迭代器改写： 
    ```cpp 
    for(vector<int>::iterator itr=v.begin();itr!=v.end();itr.???)
    cout << itr.??? << endl;
    ```
    可以看到begin()和end()的对应关系。其中迭代器的一些未知方法使用???代替。  
2. **迭代器方法**  
    上面代码说明迭代器可以使用 != 和 == 进行比较，可能需要定义一些拷贝构造函数和operator= 函数。迭代器的许多方法使用到运算符重载。  
    - itr++和++itr  
    将迭代器推进到下一位  
    - *itr  
    返回对存储在itr位置上对象的引用。返回的引用可选择是否允许修改。  
    - itr1 == itr2; itr1 != itr2  
    判断itr1和itr2是否指向同一个位置。  

    完善打印代码：  
    ```cpp
    for (vector<int>::iterator itr = v.begin(); itr != v.end(); itr++)
      cout << *itr << endl;
    ```
    可以访问当前项，此时使用*itr++可以推进到下一项。可改写为：  
    ```cpp
    vector<int>::iterator itr = v.begin();
    while (itr != v.end())
      cout << *itr++ << endl;
    ```
    ++优先级比*更高，编译器将其理解为\*(itr++)。  
    itr++创建一个副本，这个副本仍为itr当前指向位置，而itr向后移动一位，这个表达式返回这个副本，被\*作用之后返回itr原先指向的位置。下一轮循环中，itr已经成功后移一位。
3. 需要迭代器的容器操作  
  三个最流行的操作是从表的指定位置进行添加或删除的操作。  
    - iterator insert(iterator pos, const Object &x)  
    把x添加到pos之前的位置。  
    这是对list的常数时间操作。  
    返回值是指向被插入项的位置的迭代器。  
    - iterator erase(iterator pos)  
    删除pos位置上的对象。  
    这是对list的常数时间操作。  
    返回值是在调用函数之前，pos的后继元素所在的位置。  
    - iterator erase(iterator start, iterater end)  
    删除从[start, end)位置的所有对象。删除整个表可调用 c.erase(c.begin(), c.end())。  
    返回值是被删除区间之后的第一个对象所在的位置。
## 3.3.2 例子：对表使用erase
