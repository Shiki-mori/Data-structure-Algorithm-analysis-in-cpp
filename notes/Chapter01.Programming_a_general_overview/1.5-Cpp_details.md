# C++细节
## 1.5.1 指针 pointer
```cpp
//1.11 使用指向IntCell的指针
#include <iostream>
using namespace std;
class IntCell {
public:
  explicit IntCell(int initialValue = 0) : storedValue{initialValue} {};
  int read() const { return storedValue; }
  void write(int x) { storedValue = x; }

private:
  int storedValue;
};
int main() {
  IntCell *m = nullptr;

  m = new IntCell{0};
  m->write(5);
  cout << "Cell contents: " << m->read();

  delete m;
  return 0;
}
```
将程序1.9改写为为IntCell动态分配内存。  
C++不检验指针在使用前是否被赋值。未经初始化指针的使用通常会使程序崩溃。  
- 对象的动态创建  
new操作符返回一个指向新创建对象的指针。  
使用无参构造函数创建对象：  
`m = new IntCell();`  
`m = new IntCell{};`  
`m = new IntCell;  //本书首选`  
- 垃圾收集与delete  
某些语言在对象不再被引用时自动进行垃圾回收。C++不进行垃圾回收。必须使用delete操作。否则直到程序终止，该对象使用的内存将会丢失，称为内存泄漏（memory leak）。这在许多C++程序中普遍存在。很多内存泄漏源可自动被审慎地清除。一个重要规则是，在能够使用自动变量的时候不要使用new 操作符。  
- 指针的赋值和比较  
C++中指针变量的赋值和比较基于指针的值，即其所存储的地址。  
于是，指针指向相同对象，则指针变量相等。  
- 通过指针访问对象成员  
指针变量指向类类型的对象，则所指对象的可见成员能通过->操作符被访问。  
- 取地址操作符 & address-of operator  
该操作符返回一个对象所占用的内存地址。  
## 1.5.2 左值，右值，引用  
引用类型（reference type）  
新的引用类型的创建，叫做右值引用（rvalue reference）。  

左值（lvalue）是标识非临时性对象的表达式。  
右值（rvalue）是标识临时性对象的表达式，或者不与任何对象相联系的值。  

考虑如下代码：  
```cpp
vector<string> arr(3);
const int x = 2;
int y;
int z = x + y;
string str = "foo";
vector<string> *ptr = &arr;
```
一般法则是，如果程序中有一个变量名，那么它就是左值，而不论是否可被修改。  
字面值（literal）是右值。  
如果函数调用计算一个其值在被调用前不存在，且调用终止后就不再存在的表达式，那么它很可能是一个右值，除非在别处被复制。

引用类型允许为已存在的值定义新名字。  
传统C++中，引用一般只能是左值的名字。若对临时量引用，则导致对理论上已经声明不再需要的对象的访问的能力，这样可能让它的资源被声明为另外的对象所用。  
C++11中，有两种类型的引用，左值引用和右值引用。  

**2026/1/11 20:24**

**左值引用**   
声明：在某个类型后放置一个符号&。左值引用成为它所引用的对象的同义词。  
```cpp
string str = "hell";
string &rstr = str;
rstr += '0';
bool cond = (&str == &rstr);
string &bad1 = "hello";         // invalid
string &bad2 = str + " ";       // invalid:str+" " isn't lvalue
string &sub = str.substr(0, 4); // invalid:str.substr(0, 4) isn't lvalue
```
**右值引用**  
声明：在某个类型后放置一个符号&&。右值引用可以引用一个右值，即一个临时量。  
```cpp
string str = "hell";
string &&bad1 = "hello";
string &&bad2 = str + " ";
string &&sub = str.substr(0, 4);
```
以上声明都是合法的。  

左值引用有明显用途，右值引用用途则不明显，将在下一节1.5.3讨论。  

**左值引用的用途**  
1. 给结构复杂的名称起别名  
代码形式与下面类似。使用引用变量。如果去掉&符号，将建立拷贝，使得最终的push_back()操作作用于该拷贝，而不是在原始对象上。
```cpp
auto &whichList = theLists[myhash(x, theLists.size())];
if (find(begin(whichList), end(whichList), x) != end(whichList))
  return false;
whichList.push_back(x);
```
2. 范围for循环  
假设要使一个vector对象的所有值增加1，使用范围for循环需要引用。如果不使用引用，x需要担任vector中每个值的拷贝。因为范围for循环只允许对项的查看，使用引用可以使其对项进行修改。实际上需要的是让x是vector中每个值的另一个名字。
```cpp
for (auto &x : arr)
  ++x;
```
3. 避免复制  
假设有一个函数findMax，对vector对象进行操作。给定vector arr，如果调用findMax，会写  
`auto x = findMax(arr);`  
得到的x将是arr中最大值的一个拷贝。但是在很多实例中，只需要获得这个值，而要求x不发生变化。此时将x声明为引用类型（auto将推导出常态性（constness），若不使用auto，则通常用const明确规定一个不可更改的引用）：  
`auto &x = findMax(arr);`  
这需要findMax指定一个标识引用变量的返回类型。  
-  引用变量常用于避免越过函数调用界限复制对象。
-  为了使用引用代替复制能够进行传递和返回，在函数声明和返回中是需要语法的。  
## 1.5.3 参数传递
许多语言使用传值调用（call-by-value）传递所有参数：把实参复制到形参。但是C++中的参数可能是复杂的对象，复制对象的效率很低。并且有时需要能改变传递过来的值。于是C++历史上产生了3中不同的传参方法，C++11增加第4种。  

为什么传值调用不足以作为C++中唯一的传参机制？考虑以下代码：
```cpp
double average(double a, double b);
void swap(double a, double b);
string randomItem(vector<string> arr);
```
average是传值调用的理想情景。average返回时传入的参数不变。  

swap调用时，传值调用使得传入参数的值不可能发生变化。需要将参数声明为引用型参数：  
`void swap(double &a, double &b);`  
这种参数传递以前叫做**传引用调用**（call-by-reference）。C++11中，称为**传左值引用调用**（call-by-lvalue-reference）。  

randomItem()要从vector对象中返回一个随机项。传值调用使得在调用函数时对vector对象先进行拷贝，这个操作将消耗不必要的资源。通常，拷贝的唯一目的是对拷贝进行修改，并保留原始的数据。但是randomItem函数不需要进行修改操作。因此可在进行调用`randomItem(vec)`中声明arr为为vec的常量引用来避免复制，同时arr是const，不能被修改。这本质上提供了与传值调用相同的可见行为：  
`string randomItem(const vector<string> &arr);`  
这种参数传递叫做**传对常量引用的调用**（call-by-reference-to-a-constant），可简单称作**传常量引用调用**（call-by-constant reference）。  

这三种传参机制可用过两部分来决定：  
1. 如果要使形参能改变实参的值，使用传引用调用。  
2. 否则（不使形参能改变实参），如果类型为基本类型，使用传值调用。类型不是基本类型，一般使用传常量引用调用，除非实参是非常小且易复制的类型。  

换个说法：  
1. 对于小的不应被函数改变的对象，传值调用。
2. 对于大的不应被函数改变且复制代价昂贵的对象，传常量引用调用。
3. 对于所有可以被函数改变的对象，传引用调用。  

C++11的右值引用带来第四种传参方式：**传右值引用调用**（call-by-rvalue-reference）。  
由于右值存储要被销毁的临时量，`x = rvalue`这样的表达式可以通过移动而不是复制来实现，移动一个对象的状态要比复制容易得多，这可能只涉及一次简单的指针改变。  
对于`x = y;`，若y是左值，则是一次复制；若y是右值，则是一次移动。这给出一个基于参数是左值还是右值而重载函数的基本使用情况：  
```cpp
string randomItem(const vector<string> &arr); // 返回左值arr的随机项
string randomItem(vector<string> &&arr);      // 返回右值arr中的随机项

vector<string> v{"hello", "world"};
cout << randomItem(v) << endl;                  // 调用左值的方法
cout << randomItem({"hello", "world"}) << endl; // 调用右值的方法
```
这种做法最常见的使用是在定义=的行为以及编写构造函数上。

**2026/1/12 1:40**

## 1.5.4 返回值传递
从函数返回有几种不同机制。最直接的机制是**传值返回**（return-by-value）：  
```cpp
double average(double a, double b);
LargeType randomItem(const vector<LargeType> &arr);
vector<int> partialSum(const vector<int> &arr);
```
函数返回一个可以被调用者使用的适当类型的对象，在所有情况下函数调用的结果都是一个右值。  
但是对randomItem的调用含有潜在的低效风险。对partialSum的调用同样有低效风险，尽管这在C++中很可能非常有效。  
```cpp
//1.12 获得数组中的一个随机项的两种版本
//第2种版本避免了临时LargeType对象的创建，但仅当调用者用一个常量引用访问它时可行
LargeType randomItem1(const vector<LargeType> &arr) {
  return arr[randomInt(0, arr.size() - 1)];
}

const LargeType &randomItem2(const vector<LargeType> &arr) {
  return arr[randomInt(0, arr.size() - 1)];
}

vector<LargeType> vec;
···
LargeType item1 = randomItem1(vec);    // 复制
LargeType item2 = randomItem2(vec);        // 复制
const LargeType &item3 = randomItem2(vec); // 不复制
```
对于randomItem，考虑两种实现。  

第一种实现使用**传值返回**。LargeType对象将作为返回序列的一部分被复制。  

第二种实现使用**传常量引用返回**（return-by-constant-reference），避免直接复制。调用者必须也使用常量引用以存取这个返回值，否则仍将存在拷贝。常量引用意味着不想让调用者通过使用返回值制造变化。另一种做法是使用auto &声明item3，由于arr本身就是不可修改的vector对象，item3将自动声明为const。

```cpp
// 1.13 在C++11中返回栈分配的右值
vector<int> partialSum(const vector<int> &arr) {
  vector<int> result(arr.size());

  result[0] = arr[0];
  for (int i = 1; i < arr.size(); i++)
    result[i] = result[i - 1] + arr[i];

  return result;
}
vector<int> vec;
... 
vector<int> sums = partialSum(vec); // 在传统C++中是复制，在C++11中是移动
```
1.13演示了在传统C++中由于拷贝的创建和清除，传值调用是低效的。  
C++11中可以定义当看到传值返回时可以使用的移动语义。所得到的vector对象将被移动至sums，开销代价很小。将在1.5.6讨论移动语义。

除了传值返回和传常量引用返回，还有传引用返回（return-by-reference），允许函数调用者有权修改类的内部数据表示。  
## 1.5.5 std::swap和std::move
本节将讨论一些实例，C++11允许使用move取代昂贵的复制。
```cpp
//1.14 通过3次复制的交换
void swap(double &x, double &y) {
  double temp = x;
  x = y;
  y = temp;
}

void swap(vector<string> &x, vector<string> &y) {
  vector<string> temp = x;
  x = y;
  y = temp;
}
```
使用三次复制可以实现两个数据的交换。但是对于大型类型的复制代价高昂。实际上没有必要复制，这个过程中需要的是移动。C++11中如果=右边（或构造函数）是一个右值，那么当对象支持移动操作时可以自动避免复制。如果vector<string>支持移动，且x是一个右值，那么x就可以移动到temp，y移动到x同理。vector确实支持移动，但是x，y，temp都是左值：如果对象有名字，那么就是左值。
```cpp
//1.15 通过3次移动的两种交换
//第一种通过强制类型转换实现
//第二种使用std::move
using namespace std;
void swap(vector<string> &x, vector<string> &y) {
  vector<string> temp = static_cast<vector<string> &&>(x);
  x = static_cast<vector<string> &&>(y);
  y = static_cast<vector<string> &&>(temp);
}

void swap(vector<string> &x, vector<string> &y) {
  vector<string> temp = std::move(x);
  x = std::move(y);
  y = move(temp);
}
```
1.15解决了上述问题。  
第一种实现使用静态强制转换。  
第二种实现使用std::move，这个函数能将任何左值（或右值）转换成右值。move函数实际上不移动任何值，而是使得值变得易于移动。  

交换函数std::swap也是标准库的一部分，可以对任何类型的数据进行交换。

*2026/1/13 0:26*
## 1.5.6 五大函数(big-five)：析构(destructor) 拷贝构造(copy constructor) 移动构造(move constructor) 拷贝赋值运算符operator=(copy assignment operator) 移动赋值运算符operator=(move assignment operator) 
类与这五个特殊函数紧密相关。