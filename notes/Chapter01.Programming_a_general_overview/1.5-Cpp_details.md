# C++细节
## 1.5.1 指针 pointer
```cpp
//1.11 使用指向IntCell的指针
#include <iostream>
using namespace std;
class IntCell {
public:
  explicit IntCell(int initialValue = 0) : storedValue{initialValue} {};
  int read() const { return storedValue; }
  void write(int x) { storedValue = x; }

private:
  int storedValue;
};
int main() {
  IntCell *m = nullptr;

  m = new IntCell{0};
  m->write(5);
  cout << "Cell contents: " << m->read();

  delete m;
  return 0;
}
```
将程序1.9改写为为IntCell动态分配内存。  
C++不检验指针在使用前是否被赋值。未经初始化指针的使用通常会使程序崩溃。  
- 对象的动态创建  
new操作符返回一个指向新创建对象的指针。  
使用无参构造函数创建对象：  
`m = new IntCell();`  
`m = new IntCell{};`  
`m = new IntCell;  //本书首选`  
- 垃圾收集与delete  
某些语言在对象不再被引用时自动进行垃圾回收。C++不进行垃圾回收。必须使用delete操作。否则直到程序终止，该对象使用的内存将会丢失，称为内存泄漏（memory leak）。这在许多C++程序中普遍存在。很多内存泄漏源可自动被审慎地清除。一个重要规则是，在能够使用自动变量的时候不要使用new 操作符。  
- 指针的赋值和比较  
C++中指针变量的赋值和比较基于指针的值，即其所存储的地址。  
于是，指针指向相同对象，则指针变量相等。  
- 通过指针访问对象成员  
指针变量指向类类型的对象，则所指对象的可见成员能通过->操作符被访问。  
- 取地址操作符 & address-of operator  
该操作符返回一个对象所占用的内存地址。  
## 1.5.2 左值，右值，引用  
引用类型（reference type）  
新的引用类型的创建，叫做右值引用（rvalue reference）。  

左值（lvalue）是标识非临时性对象的表达式。  
右值（rvalue）是标识临时性对象的表达式，或者不与任何对象相联系的值。  

考虑如下代码：  
```cpp
vector<string> arr(3);
const int x = 2;
int y;
int z = x + y;
string str = "foo";
vector<string> *ptr = &arr;
```
一般法则是，如果程序中有一个变量名，那么它就是左值，而不论是否可被修改。  
字面值（literal）是右值。  
如果函数调用计算一个其值在被调用前不存在，且调用终止后就不再存在的表达式，那么它很可能是一个右值，除非在别处被复制。

引用类型允许为已存在的值定义新名字。  
传统C++中，引用一般只能是左值的名字。若对临时量引用，则导致对理论上已经声明不再需要的对象的访问的能力，这样可能让它的资源被声明为另外的对象所用。  
C++11中，有两种类型的引用，左值引用和右值引用。  

**2026/1/11 20:24**

**左值引用**   
声明：在某个类型后放置一个符号&。左值引用成为它所引用的对象的同义词。  
```cpp
string str = "hell";
string &rstr = str;
rstr += '0';
bool cond = (&str == &rstr);
string &bad1 = "hello";         // invalid
string &bad2 = str + " ";       // invalid:str+" " isn't lvalue
string &sub = str.substr(0, 4); // invalid:str.substr(0, 4) isn't lvalue
```
**右值引用**  
声明：在某个类型后放置一个符号&&。右值引用可以引用一个右值，即一个临时量。  
```cpp
string str = "hell";
string &&bad1 = "hello";
string &&bad2 = str + " ";
string &&sub = str.substr(0, 4);
```
以上声明都是合法的。  

左值引用有明显用途，右值引用用途则不明显，将在下一节1.5.3讨论。  

**左值引用的用途**  
1. 给结构复杂的名称起别名  
代码形式与下面类似。使用引用变量。如果去掉&符号，将建立拷贝，使得最终的push_back()操作作用于该拷贝，而不是在原始对象上。
```cpp
auto &whichList = theLists[myhash(x, theLists.size())];
if (find(begin(whichList), end(whichList), x) != end(whichList))
  return false;
whichList.push_back(x);
```
2. 范围for循环  
假设要使一个vector对象的所有值增加1，使用范围for循环需要引用。如果不使用引用，x需要担任vector中每个值的拷贝。因为范围for循环只允许对项的查看，使用引用可以使其对项进行修改。实际上需要的是让x是vector中每个值的另一个名字。
```cpp
for (auto &x : arr)
  ++x;
```
3. 避免复制  
假设有一个函数findMax，对vector对象进行操作。给定vector arr，如果调用findMax，会写  
`auto x = findMax(arr);`  
得到的x将是arr中最大值的一个拷贝。但是在很多实例中，只需要获得这个值，而要求x不发生变化。此时将x声明为引用类型（auto将推导出常态性（constness），若不使用auto，则通常用const明确规定一个不可更改的引用）：  
`auto &x = findMax(arr);`  
这需要findMax指定一个标识引用变量的返回类型。  
-  引用变量常用于避免越过函数调用界限复制对象。
-  为了使用引用代替复制能够进行传递和返回，在函数声明和返回中是需要语法的。  
## 1.5.3 参数传递
许多语言使用传值调用（call-by-value）传递所有参数：把实参复制到形参。但是C++中的参数可能是复杂的对象，复制对象的效率很低。并且有时需要能改变传递过来的值。于是C++历史上产生了3中不同的传参方法，C++11增加第4种。  

为什么传值调用不足以作为C++中唯一的传参机制？考虑以下代码：
```cpp
double average(double a, double b);
void swap(double a, double b);
string randomItem(vector<string> arr);
```
average是传值调用的理想情景。average返回时传入的参数不变。  

swap调用时，传值调用使得传入参数的值不可能发生变化。需要将参数声明为引用型参数：  
`void swap(double &a, double &b);`  
这种参数传递以前叫做**传引用调用**（call-by-reference）。C++11中，称为**传左值引用调用**（call-by-lvalue-reference）。  

randomItem()要从vector对象中返回一个随机项。传值调用使得在调用函数时对vector对象先进行拷贝，这个操作将消耗不必要的资源。通常，拷贝的唯一目的是对拷贝进行修改，并保留原始的数据。但是randomItem函数不需要进行修改操作。因此可在进行调用`randomItem(vec)`中声明arr为为vec的常量引用来避免复制，同时arr是const，不能被修改。这本质上提供了与传值调用相同的可见行为：  
`string randomItem(const vector<string> &arr);`  
这种参数传递叫做**传对常量引用的调用**（call-by-reference-to-a-constant），可简单称作**传常量引用调用**（call-by-constant reference）。  

这三种传参机制可用过两部分来决定：  
1. 如果要使形参能改变实参的值，使用传引用调用。  
2. 否则（不使形参能改变实参），如果类型为基本类型，使用传值调用。类型不是基本类型，一般使用传常量引用调用，除非实参是非常小且易复制的类型。  

换个说法：  
1. 对于小的不应被函数改变的对象，传值调用。
2. 对于大的不应被函数改变且复制代价昂贵的对象，传常量引用调用。
3. 对于所有可以被函数改变的对象，传引用调用。  

C++11的右值引用带来第四种传参方式：**传右值引用调用**（call-by-rvalue-reference）。  
由于右值存储要被销毁的临时量，`x = rvalue`这样的表达式可以通过移动而不是复制来实现，移动一个对象的状态要比复制容易得多，这可能只涉及一次简单的指针改变。  
对于`x = y;`，若y是左值，则是一次复制；若y是右值，则是一次移动。这给出一个基于参数是左值还是右值而重载函数的基本使用情况：  
```cpp
string randomItem(const vector<string> &arr); // 返回左值arr的随机项
string randomItem(vector<string> &&arr);      // 返回右值arr中的随机项

vector<string> v{"hello", "world"};
cout << randomItem(v) << endl;                  // 调用左值的方法
cout << randomItem({"hello", "world"}) << endl; // 调用右值的方法
```
这种做法最常见的使用是在定义=的行为以及编写构造函数上。

**2026/1/12 1:40**

## 1.5.4 返回值传递