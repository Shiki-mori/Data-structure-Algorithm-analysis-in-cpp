# C++细节
## 1.5.1 指针 pointer
```cpp
//1.11 使用指向IntCell的指针
#include <iostream>
using namespace std;
class IntCell {
public:
  explicit IntCell(int initialValue = 0) : storedValue{initialValue} {};
  int read() const { return storedValue; }
  void write(int x) { storedValue = x; }

private:
  int storedValue;
};
int main() {
  IntCell *m = nullptr;

  m = new IntCell{0};
  m->write(5);
  cout << "Cell contents: " << m->read();

  delete m;
  return 0;
}
```
将程序1.9改写为为IntCell动态分配内存。  
C++不检验指针在使用前是否被赋值。未经初始化指针的使用通常会使程序崩溃。  
- 对象的动态创建  
new操作符返回一个指向新创建对象的指针。  
使用无参构造函数创建对象：  
`m = new IntCell();`  
`m = new IntCell{};`  
`m = new IntCell;  //本书首选`  
- 垃圾收集与delete  
某些语言在对象不再被引用时自动进行垃圾回收。C++不进行垃圾回收。必须使用delete操作。否则直到程序终止，该对象使用的内存将会丢失，称为内存泄漏（memory leak）。这在许多C++程序中普遍存在。很多内存泄漏源可自动被审慎地清除。一个重要规则是，在能够使用自动变量的时候不要使用new 操作符。  
- 指针的赋值和比较  
C++中指针变量的赋值和比较基于指针的值，即其所存储的地址。  
于是，指针指向相同对象，则指针变量相等。  
- 通过指针访问对象成员  
指针变量指向类类型的对象，则所指对象的可见成员能通过->操作符被访问。  
- 取地址操作符 & address-of operator  
该操作符返回一个对象所占用的内存地址。  
## 1.5.2 左值，右值，引用  
引用类型（reference type）  
新的引用类型的创建，叫做右值引用（rvalue reference）。  

左值（lvalue）是标识非临时性对象的表达式。  
右值（rvalue）是标识临时性对象的表达式，或者不与任何对象相联系的值。  

考虑如下代码：  
```cpp
vector<string> arr(3);
const int x = 2;
int y;
int z = x + y;
string str = "foo";
vector<string> *ptr = &arr;
```
一般法则是，如果程序中有一个变量名，那么它就是左值，而不论是否可被修改。  
字面值（literal）是右值。  
如果函数调用计算一个其值在被调用前不存在，且调用终止后就不再存在的表达式，那么它很可能是一个右值，除非在别处被复制。

引用类型允许为已存在的值定义新名字。  
传统C++中，引用一般只能是左值的名字。若对临时量引用，则导致对理论上已经声明不再需要的对象的访问的能力，这样可能让它的资源被声明为另外的对象所用。  
C++11中，有两种类型的引用，左值引用和右值引用。  

**2026/1/11 20:24**

**左值引用**   
声明：在某个类型后放置一个符号&。左值引用成为它所引用的对象的同义词。  
```cpp
string str = "hell";
string &rstr = str;
rstr += '0';
bool cond = (&str == &rstr);
string &bad1 = "hello";         // invalid
string &bad2 = str + " ";       // invalid:str+" " isn't lvalue
string &sub = str.substr(0, 4); // invalid:str.substr(0, 4) isn't lvalue
```
**右值引用**  
声明：在某个类型后放置一个符号&&。右值引用可以引用一个右值，即一个临时量。  
```cpp
string str = "hell";
string &&bad1 = "hello";
string &&bad2 = str + " ";
string &&sub = str.substr(0, 4);
```
以上声明都是合法的。  

左值引用有明显用途，右值引用用途则不明显，将在下一节1.5.3讨论。  

**左值引用的用途**  
1. 给结构复杂的名称起别名  
代码形式与下面类似。使用引用变量。如果去掉&符号，将建立拷贝，使得最终的push_back()操作作用于该拷贝，而不是在原始对象上。
    ```cpp
    auto &whichList = theLists[myhash(x, theLists.size())];
    if (find(begin(whichList), end(whichList), x) != end(whichList))
      return false;
    whichList.push_back(x);
    ```
2. 范围for循环  
假设要使一个vector对象的所有值增加1，使用范围for循环需要引用。如果不使用引用，x需要担任vector中每个值的拷贝。因为范围for循环只允许对项的查看，使用引用可以使其对项进行修改。实际上需要的是让x是vector中每个值的另一个名字。
    ```cpp
    for (auto &x : arr)
      ++x;
    ```
3. 避免复制  
假设有一个函数findMax，对vector对象进行操作。给定vector arr，如果调用findMax，会写  
`auto x = findMax(arr);`  
得到的x将是arr中最大值的一个拷贝。但是在很多实例中，只需要获得这个值，而要求x不发生变化。此时将x声明为引用类型（auto将推导出常态性（constness），若不使用auto，则通常用const明确规定一个不可更改的引用）：  
`auto &x = findMax(arr);`  
这需要findMax指定一个标识引用变量的返回类型。  
-  引用变量常用于避免越过函数调用界限复制对象。
-  为了使用引用代替复制能够进行传递和返回，在函数声明和返回中是需要语法的。  
## 1.5.3 参数传递
许多语言使用传值调用（call-by-value）传递所有参数：把实参复制到形参。但是C++中的参数可能是复杂的对象，复制对象的效率很低。并且有时需要能改变传递过来的值。于是C++历史上产生了3中不同的传参方法，C++11增加第4种。  

为什么传值调用不足以作为C++中唯一的传参机制？考虑以下代码：
```cpp
double average(double a, double b);
void swap(double a, double b);
string randomItem(vector<string> arr);
```
average是传值调用的理想情景。average返回时传入的参数不变。  

swap调用时，传值调用使得传入参数的值不可能发生变化。需要将参数声明为引用型参数：  
`void swap(double &a, double &b);`  
这种参数传递以前叫做**传引用调用**（call-by-reference）。C++11中，称为**传左值引用调用**（call-by-lvalue-reference）。  

randomItem()要从vector对象中返回一个随机项。传值调用使得在调用函数时对vector对象先进行拷贝，这个操作将消耗不必要的资源。通常，拷贝的唯一目的是对拷贝进行修改，并保留原始的数据。但是randomItem函数不需要进行修改操作。因此可在进行调用`randomItem(vec)`中声明arr为为vec的常量引用来避免复制，同时arr是const，不能被修改。这本质上提供了与传值调用相同的可见行为：  
`string randomItem(const vector<string> &arr);`  
这种参数传递叫做**传对常量引用的调用**（call-by-reference-to-a-constant），可简单称作**传常量引用调用**（call-by-constant reference）。  

这三种传参机制可用过两部分来决定：  
1. 如果要使形参能改变实参的值，使用传引用调用。  
2. 否则（不使形参能改变实参），如果类型为基本类型，使用传值调用。类型不是基本类型，一般使用传常量引用调用，除非实参是非常小且易复制的类型。  

换个说法：  
1. 对于小的不应被函数改变的对象，传值调用。
2. 对于大的不应被函数改变且复制代价昂贵的对象，传常量引用调用。
3. 对于所有可以被函数改变的对象，传引用调用。  

C++11的右值引用带来第四种传参方式：**传右值引用调用**（call-by-rvalue-reference）。  
由于右值存储要被销毁的临时量，`x = rvalue`这样的表达式可以通过移动而不是复制来实现，移动一个对象的状态要比复制容易得多，这可能只涉及一次简单的指针改变。  
对于`x = y;`，若y是左值，则是一次复制；若y是右值，则是一次移动。这给出一个基于参数是左值还是右值而重载函数的基本使用情况：  
```cpp
string randomItem(const vector<string> &arr); // 返回左值arr的随机项
string randomItem(vector<string> &&arr);      // 返回右值arr中的随机项

vector<string> v{"hello", "world"};
cout << randomItem(v) << endl;                  // 调用左值的方法
cout << randomItem({"hello", "world"}) << endl; // 调用右值的方法
```
这种做法最常见的使用是在定义=的行为以及编写构造函数上。

**2026/1/12 1:40**

## 1.5.4 返回值传递
从函数返回有几种不同机制。最直接的机制是**传值返回**（return-by-value）：  
```cpp
double average(double a, double b);
LargeType randomItem(const vector<LargeType> &arr);
vector<int> partialSum(const vector<int> &arr);
```
函数返回一个可以被调用者使用的适当类型的对象，在所有情况下函数调用的结果都是一个右值。  
但是对randomItem的调用含有潜在的低效风险。对partialSum的调用同样有低效风险，尽管这在C++中很可能非常有效。  
```cpp
//1.12 获得数组中的一个随机项的两种版本
//第2种版本避免了临时LargeType对象的创建，但仅当调用者用一个常量引用访问它时可行
LargeType randomItem1(const vector<LargeType> &arr) {
  return arr[randomInt(0, arr.size() - 1)];
}

const LargeType &randomItem2(const vector<LargeType> &arr) {
  return arr[randomInt(0, arr.size() - 1)];
}

vector<LargeType> vec;
···
LargeType item1 = randomItem1(vec);    // 复制
LargeType item2 = randomItem2(vec);        // 复制
const LargeType &item3 = randomItem2(vec); // 不复制
```
对于randomItem，考虑两种实现。  

第一种实现使用**传值返回**。LargeType对象将作为返回序列的一部分被复制。  

第二种实现使用**传常量引用返回**（return-by-constant-reference），避免直接复制。调用者必须也使用常量引用以存取这个返回值，否则仍将存在拷贝。常量引用意味着不想让调用者通过使用返回值制造变化。另一种做法是使用auto &声明item3，由于arr本身就是不可修改的vector对象，item3将自动声明为const。

```cpp
// 1.13 在C++11中返回栈分配的右值
vector<int> partialSum(const vector<int> &arr) {
  vector<int> result(arr.size());

  result[0] = arr[0];
  for (int i = 1; i < arr.size(); i++)
    result[i] = result[i - 1] + arr[i];

  return result;
}
vector<int> vec;
... 
vector<int> sums = partialSum(vec); // 在传统C++中是复制，在C++11中是移动
```
1.13演示了在传统C++中由于拷贝的创建和清除，传值调用是低效的。  
C++11中可以定义当看到传值返回时可以使用的移动语义。所得到的vector对象将被移动至sums，开销代价很小。将在1.5.6讨论移动语义。

除了传值返回和传常量引用返回，还有传引用返回（return-by-reference），允许函数调用者有权修改类的内部数据表示。  
## 1.5.5 std::swap和std::move
本节将讨论一些实例，C++11允许使用move取代昂贵的复制。
```cpp
//1.14 通过3次复制的交换
void swap(double &x, double &y) {
  double temp = x;
  x = y;
  y = temp;
}

void swap(vector<string> &x, vector<string> &y) {
  vector<string> temp = x;
  x = y;
  y = temp;
}
```
使用三次复制可以实现两个数据的交换。但是对于大型类型的复制代价高昂。实际上没有必要复制，这个过程中需要的是移动。C++11中如果=右边（或构造函数）是一个右值，那么当对象支持移动操作时可以自动避免复制。如果vector<string>支持移动，且x是一个右值，那么x就可以移动到temp，y移动到x同理。vector确实支持移动，但是x，y，temp都是左值：如果对象有名字，那么就是左值。
```cpp
//1.15 通过3次移动的两种交换
//第一种通过强制类型转换实现
//第二种使用std::move
using namespace std;
void swap(vector<string> &x, vector<string> &y) {
  vector<string> temp = static_cast<vector<string> &&>(x);
  x = static_cast<vector<string> &&>(y);
  y = static_cast<vector<string> &&>(temp);
}

void swap(vector<string> &x, vector<string> &y) {
  vector<string> temp = std::move(x);
  x = std::move(y);
  y = move(temp);
}
```
1.15解决了上述问题。  
第一种实现使用静态强制转换。  
第二种实现使用std::move，这个函数能将任何左值（或右值）转换成右值。move函数实际上不移动任何值，而是使得值变得易于移动。  

交换函数std::swap也是标准库的一部分，可以对任何类型的数据进行交换。

*2026/1/13 0:26*
## 1.5.6 五大函数(big-five)：析构(destructor) 拷贝构造(copy constructor) 移动构造(move constructor) 拷贝赋值运算符operator=(copy assignment operator) 移动赋值运算符operator=(move assignment operator) 
类与这五个特殊函数紧密相关。  
- **析构函数**  
对象运行越出范围，或被delete，则析构函数被调用。典型情况下析构函数的唯一责任就是释放掉在对象使用期间获得的资源，包括关于任意的new操作调用对应的delete，关闭任何打开的文件等等。默认做法是对每个数据成员应用析构函数。  
- **拷贝构造函数和移动构造函数**  
这两个特殊构造函数用来构造新的对象，被初始化为与另一个同样类型对象相同的状态。如果这个已存在对象是左值，使用拷贝构造函数；是右值（临时量）则使用移动构造函数。示例如下：  
  - 带有初始化的声明：  
`IntCell B = C;`  
`IntCell B {C};`  
C是左值使用拷贝构造函数，右值使用移动构造函数。  
  - 不适用于`B = C;  //赋值运算符`。
  - 传值调用所传递的对象很少这么做。  
  - 传值返回的对象。如果返回的对象是左值，调用拷贝构造函数；右值调用移动构造函数。  

  默认情况下，拷贝构造函数的实现是通过将拷贝构造函数依次应用到每个数据成员来完成的。对于基本类型数据成员，进行简单赋值即可。对于类对象数据成员，则对于每个这样的数据成员的类，对其数据成员使用拷贝或移动构造函数。

- **拷贝赋值和移动赋值**（operator=）   
当=用于两个已被构造的对象时，调用赋值运算符。默认拷贝赋值运算符通过依次对每个数据成员使用拷贝赋值运算符来实现。  
- **默认情形**  
  如果一个类由一些数据成员组成，而这些数据成员是一些基本类型数据以及对其进行默认处理有意义的对象，那么这个类的默认值通常是有意义的。比如数据成员是int，vector\<string\>的类。  
  主要问题发生在包含有指针作为数据成员的类中。第三章将详述。这里进行概述。**浅拷贝**（shallow copy）：拷贝构造函数和拷贝赋值运算符均复制指针的值而不是其指向的对象，这样将得到两个指针指向相同对象的类。但典型情况要求得到**深拷贝**（deep copy）。  
  当一个类包含指针数据成员时，一般必须自己实现析构函数、拷贝赋值和拷贝构造函数。这样做排除了移动的默认情形，因此也必须实现移动赋值和移动构造函数。  

  作为一般法则，有三种选择：  
  1. 接受对所有5种操作的默认处理；  
  2. 声明并显式定义所有5个函数的默认情形（使用关键字default）；  
  3. 每个都不予接受（使用关键字delete）。  
  一般来说，对所有的5个函数都给出定义。  
  
  对于IntCell，这些操作的形式是：  
  ```cpp
  class IntCell {
   ~IntCell();                             // 析构函数
   IntCell(const IntCell &rhs);            // 拷贝构造函数
   IntCell(IntCell &&rhs);                 // 移动构造函数
   IntCell &operator=(const IntCell &rhs); // 拷贝赋值
   IntCell &operator=(IntCell &&rhs);      // 移动赋值
  };
  ```
  operator= 的返回类型是对调用对象的一个引用，以便允许链式赋值a=b=c。这是使用习惯，更严格来说应该返回一个常量引用。  

  如果编写五大函数中任意一个，显式地考虑其他几个是好习惯，因为默认值可能非法或不当。在以下简单例子里，调试代码放在析构函数中，这将保证不会产生默认的移动操作，即用户声明析构函数将使得移动赋值和移动构造函数不会自动生成，但是仍会隐式生成拷贝操作。但这种保证还是会遭到反对，因为只抑制移动操作而不抑制拷贝操作具有不一致性，很可能不会再出现在语言未来的版本中。因此最好再次显式地列出拷贝和移动操作：  
  ```cpp
  class IntCell {
    ~IntCell() { cout << "Invoking destructor" << endl; } // 析构函数
    IntCell(const IntCell &rhs) = default;                // 拷贝构造函数
    IntCell(IntCell &&rhs) = default;                     // 移动构造函数
    IntCell &operator=(const IntCell &rhs) = default;     // 拷贝赋值
    IntCell &operator=(IntCell &&rhs) = default;          // 移动赋值
  };
  ```
  另一种做法是不允许对IntCell对象的所有复制或移动：  
  ```cpp
  class IntCell {
    IntCell(const IntCell &rhs) = delete;            // 无拷贝构造函数
    IntCell(IntCell &&rhs) = delete;                 // 无移动构造函数
    IntCell &operator=(const IntCell &rhs) = delete; // 无拷贝赋值
    IntCell &operator=(IntCell &&rhs) = delete;      // 无移动赋值
  };
  ```

  若默认操作有意义，将总是接受默认操作。  
  若默认操作没有意义，就需要实现析构、拷贝构造、移动构造函数，以及拷贝和移动赋值运算符。   
- **默认操作不起作用时**  
最常见的默认操作不起作用的情况是数据成员为指针类型，并且指针由某个对象成员函数（如构造函数）定址的时候。  
例如，通过动态定址一个int型变量来实现IntCell：  
  ```cpp
  // 1.16 数据成员为指针，默认操作不起作用
  class IntCell {
    int *storedValue;

  public:
    explicit IntCell(int initialValue = 0) {
      storedValue = new int{initialValue};
    }
    int read() const { return *storedValue; }
    void write(int x) { *storedValue = x; }
  };
  ```
  在使用类的时候，程序1.17暴露出问题。 
  ```cpp
  // 1.17 揭示1.16中的问题
  int f() {
    IntCell a{2};
    IntCell b = a;
    IntCell c;

    c = b;
    a.write(4);
    cout << a.read() << endl << b.read() << endl << c.read() << endl;
    return 0;
  }
  ```
  输出是三个4。但是逻辑上只有a应该是4。问题在于默认的拷贝赋值运算符和拷贝构造函数复制了指针storedValue，这些复制为浅拷贝，被复制的是指针而不是被指向的对象。于是三个对象的storedValue指针指向同一个int量。  
  其次，存在内存泄漏问题。  

  为了解决这些问题，需要实现五大函数，如1.18所示。
  ```cpp
  // 1.18 数据成员为指针，实现五大函数
  class IntCell {
    int *storedValue;

  public:
    explicit IntCell(int initialValue = 0) {
      storedValue = new int{initialValue};
    }

    ~IntCell() { delete storedValue; }

    IntCell(const IntCell &rhs) { storedValue = new int{*rhs.storedValue}; }

    IntCell(IntCell &&rhs) : storedValue{rhs.storedValue} {
      rhs.storedValue = nullptr;
    }

    IntCell &operator=(const IntCell &rhs) {
      if (this != &rhs)
        *storedValue = *rhs.storedValue;
      return *this;
    }

    IntCell &operator=(IntCell &&rhs) {
      std::swap(storedValue, rhs.storedValue);
      return *this;
    }

    int read() const { return *storedValue; }

    void write(int x) { *storedValue = x; }
  };
  ```
  拷贝赋值运算符使用了检测混乱现象（即自我赋值，调用obj=obj;）的标准格式，然后根据需要依次复制每个数据域，在结束时刻使用*this返回对它自己的引用。  
  C++11常常使用**拷贝和交换格式**（copy-and-swap idiom）编写拷贝赋值，导致另一种实现方法：  
  ```cpp
  IntCell &operator=(const IntCell &rhs) {
  IntCell copy = rhs;
  std::swap(*this, copy);
  return *this;
  }
  ```
  利用拷贝构造函数将rhs的拷贝置入copy。然后这个copy被交换到*this中。返回时为copy调用析构函数清理旧数据的内存。对于复杂类型来说这种操作很好用。C++11中有一个基本预期，即交换运算要么使用三次移动实现，要么通过逐项交换成员实现。  

  如果成员数据存在vector\<string\> items，移动构造函数需要声明为（非原始数据必须使用初始化表列）：  
  ```cpp
  IntCell(IntCell &&rhs)
    : storedValue{rhs.storedValue}, items{std::move(rhs.items)} {
  rhs.storedValue = nullptr;
  }
  ```
  1.18中的移动赋值运算符是通过逐项成员交换实现的。有时该操作通过与拷贝赋值运算符相同的方式作为一次对象交换实现，仅当交换本身作为逐项成员交换。如果交换由3次移动实现，将陷入相互递归中。

## 1.5.7 C风格数组和字符串
`int arr[10];`  
arr实际上是一个指向大到足以存储10个int型量的内存的指针，而不是一个第一类数组类型。因此将=用于数组即试图拷贝两个指针的值，这是非法的，因为arr是一个常量指针。当arr被传递到函数时，只传递指针的值，而关于指针大小的信息丢失了。因此数组大小必须作为附加的参数被传递。因为大小未知，因此不存在下标范围检索。  
这种声明中，数组的大小在编译时必须要知道。不能使用变量来取代10。如果大小未知，必须显式声明一个指针并通过new[]安排内存：  
`int *arr2 = new int[n];`  
arr2不是常量指针。它可以指向一大块内存。由于内存被动态分配，必须使用delete[]释放，否则将产生内存泄漏：  
`delete[] arr2;`  
C风格字符串作为字符数组实现。为避免传递字符串长度，使用空终止符（null-terminator）'\0'来表示字符串的逻辑结尾。可使用strcpy，strcmp，strlen对字符串操作。单个字符可通过数组下标操作符访问。字符串有与数组一样的问题，包括困难的内存管理。当字符串被复制时，是假设目标字符串大到足以容纳复制结果的，而容纳不下时，常常因为没有空间容纳空终止符而不得不进行困难的调试。  
标准的vector类和string类隐藏C风格数组和字符串。使用vector和string类几乎总是更好，但是当设计使用C和C++工作的库例程交互时必须使用C风格。为提高速度而必须进行优化的代码段中使用C风格偶尔也是必要的。
