# 模板
本书将描述类型无关的算法和数据结构，也称为泛型算法（generic algorithm）。本节描述泛型算法如何使用模板（template）编写。
## 1.6.1 函数模板（function template）
函数模板是可以变成一个函数的型式。1.19阐释函数模板findMax。  
```cpp
// 1.19 findMax函数模板
// 返回数组a中的最大项
// 假设a.size()>0
// 可比较的对象必须提供operator<和operator=
template <typename Comparable>
const Comparable &findMax(const vector<Comparable> &a) {
  int maxIndex = 0;
  for (int i = 1; i < a.size(); i++)
    if (a[maxIndex] < a[i])
      maxIndex = i;
  return a[maxIndex];
}
```
template声明指出，Comparable是一个模板参数，可被任何类型替代生成一个函数。例如，使用vector\<string\>作为参数对findMax进行调用，那么通过用string代替Comparable生成一个函数。
```cpp
// 1.20 findMax函数模板的使用
int main() {
  vector<int> v1(37);
  vector<double> v2(40);
  vector<string> v3(80);
  vector<IntCell> v4(75);

  cout << findMax(v1) << endl;
  cout << findMax(v2) << endl;
  cout << findMax(v3) << endl;
  cout << findMax(v4) << endl; // invalid: operator< undifined

  return 0;
}
```
1.20解释函数模板在需要时可自动展开。每个新类型的展开都会产生附加的代码，当其发生在大项目中时，就称为代码膨胀（code bloat）。   
习惯上在任何模板之前都要安排一些注释，解释关于模板参数都有哪些假设，包括关于需要一些什么类型的构造函数。  
模板参数可以假设为任意的类类型，因此在决定参数传递和返回传递时，应该假设模板参数不是基本类型。这就是采用常量引用返回的原因。  

存在许多神秘法则处理函数模板。大部分问题出在模板不能为参数提供准确匹配但是（通过隐式类型转换）接近它的时候。必须有一些方法解决歧义问题，而相关规则十分复杂。  
- 如果存在一个非模板和模板都匹配，那么优先匹配非模板。  
- 如果出现两个同等近似程度的匹配，那么代码非法并且编译程序将显示二义性。
## 1.6.2 类模板
```cpp
// 1.21 MemoryCell类模板
// 一个模拟内存单元的类
template <typename Object> class MemoryCell {
public:
  // initialValue = Object{}:默认参数，如果调用时不提供参数，使用Object{}作为默认值
  // Object{}调用Object的默认构造函数创建一个临时对象
  explicit MemoryCell(const Object &initialValue = Object{})
      : storedValue{initialValue} {}
  const Object &read() const { return storedValue; }
  void write(const Object &x) { storedValue = x; }

private:
  Object storedValue;
};
```
1.21显示MemoryCell类模板。  
假设Object有一个无参构造函数，一个拷贝构造函数和一个拷贝赋值运算符。MemoryCell为任何类型的Object工作。  
Object通过常量引用传递；构造参数的默认参数不是0，因为0不可能是合理的Object对象。默认参数使用无参构造函数构造一个Object对象所得的结果。
```cpp
// 1.22 使用MemoryCell类模板
int main() {
  MemoryCell<int> m1;
  MemoryCell<string> m2{"hello"};

  m1.write(37);
  m2.write(m2.read() + " world");
  cout << m1.read() << endl << m2.read() << endl;

  return 0;
}
```
1.22演示MemoryCell如何能够用来既存储基本类型又存储类类型的对象。MemoryCell是类模板，MemoryCell\<int\>和MemoryCell\<string\>才是两个具体的类。  

如果把类模板作为一个单一整体实现，那么几乎没有语法负担（syntax baggage）。许多类模板使用这种方式实现，因为当前模板的分离式编译在许多平台上都工作得不够好。因此许多情形下，整个的类连同其实现必须放在一个.h文件中。STL流行的实现方法遵循的就是这个策略。  

另一个做法是将类模板的接口和实现分离。这增加了额外的语法负担，从历史上看难以使编译器干净地处理。本书为避免额外语法，在必要时以在线代码的形式提供不进行接口和实现分离的类模板。  

*2026/1/14 14:23*

## 1.6.3 Object、Comparable和一个例子
