# 模板
本书将描述类型无关的算法和数据结构，也称为泛型算法（generic algorithm）。本节描述泛型算法如何使用模板（template）编写。
## 1.6.1 函数模板（function template）
函数模板是可以变成一个函数的型式。1.19阐释函数模板findMax。  
```cpp
// 1.19 findMax函数模板
// 返回数组a中的最大项
// 假设a.size()>0
// 可比较的对象必须提供operator<和operator=
template <typename Comparable>
const Comparable &findMax(const vector<Comparable> &a) {
  int maxIndex = 0;
  for (int i = 1; i < a.size(); i++)
    if (a[maxIndex] < a[i])
      maxIndex = i;
  return a[maxIndex];
}
```
template声明指出，Comparable是一个模板参数，可被任何类型替代生成一个函数。例如，使用vector\<string\>作为参数对findMax进行调用，那么通过用string代替Comparable生成一个函数。
```cpp
// 1.20 findMax函数模板的使用
int main() {
  vector<int> v1(37);
  vector<double> v2(40);
  vector<string> v3(80);
  vector<IntCell> v4(75);

  cout << findMax(v1) << endl;
  cout << findMax(v2) << endl;
  cout << findMax(v3) << endl;
  cout << findMax(v4) << endl; // invalid: operator< undifined

  return 0;
}
```
1.20解释函数模板在需要时可自动展开。每个新类型的展开都会产生附加的代码，当其发生在大项目中时，就称为代码膨胀（code bloat）。   
习惯上在任何模板之前都要安排一些注释，解释关于模板参数都有哪些假设，包括关于需要一些什么类型的构造函数。  
模板参数可以假设为任意的类类型，因此在决定参数传递和返回传递时，应该假设模板参数不是基本类型。这就是采用常量引用返回的原因。  

存在许多神秘法则处理函数模板。大部分问题出在模板不能为参数提供准确匹配但是（通过隐式类型转换）接近它的时候。必须有一些方法解决歧义问题，而相关规则十分复杂。  
- 如果存在一个非模板和模板都匹配，那么优先匹配非模板。  
- 如果出现两个同等近似程度的匹配，那么代码非法并且编译程序将显示二义性。
## 1.6.2 类模板
```cpp
// 1.21 MemoryCell类模板
// 一个模拟内存单元的类
template <typename Object> class MemoryCell {
public:
  // initialValue = Object{}:默认参数，如果调用时不提供参数，使用Object{}作为默认值
  // Object{}调用Object的默认构造函数创建一个临时对象
  explicit MemoryCell(const Object &initialValue = Object{})
      : storedValue{initialValue} {}
  const Object &read() const { return storedValue; }
  void write(const Object &x) { storedValue = x; }

private:
  Object storedValue;
};
```
1.21显示MemoryCell类模板。  
假设Object有一个无参构造函数，一个拷贝构造函数和一个拷贝赋值运算符。MemoryCell为任何类型的Object工作。  
Object通过常量引用传递；构造参数的默认参数不是0，因为0不可能是合理的Object对象。默认参数使用无参构造函数构造一个Object对象所得的结果。
```cpp
// 1.22 使用MemoryCell类模板
int main() {
  MemoryCell<int> m1;
  MemoryCell<string> m2{"hello"};

  m1.write(37);
  m2.write(m2.read() + " world");
  cout << m1.read() << endl << m2.read() << endl;

  return 0;
}
```
1.22演示MemoryCell如何能够用来既存储基本类型又存储类类型的对象。MemoryCell是类模板，MemoryCell\<int\>和MemoryCell\<string\>才是两个具体的类。  
其中的int{}初始化将创建一个值为0的临时int对象，对于基本类型int使用值初始化结果是0。 

如果把类模板作为一个单一整体实现，那么几乎没有语法负担（syntax baggage）。许多类模板使用这种方式实现，因为当前模板的分离式编译在许多平台上都工作得不够好。因此许多情形下，整个的类连同其实现必须放在一个.h文件中。STL流行的实现方法遵循的就是这个策略。  

另一个做法是将类模板的接口和实现分离。这增加了额外的语法负担，从历史上看难以使编译器干净地处理。本书为避免额外语法，在必要时以在线代码的形式提供不进行接口和实现分离的类模板。  

*2026/1/14 14:23*

## 1.6.3 Object、Comparable和一个例子
本书中Object和Comparable作为泛型类型反复使用。  
假设Object有一个无参构造函数，一个operator=，一个拷贝构造函数。  
Comparable有一个以operator<的形式用于提供全序的附加功能。  
```cpp
// 1.23 Comparable可以是一个类类型，如Square
class Square {
public:
  explicit Square(double s = 0.0) : side{s} {}
  double getSide() const { return side; }
  double getArea() const { return side * side; }
  double getPerimeter() const { return side * 4; }

  void print(ostream &out = cout) const {
    out << "(square " << getSide() << ")";
  }
  bool operator<(const Square &rhs) const { return getSide() < rhs.getSide(); }

private:
  double side;
};

// 为Square定义一个输出操作符
ostream &operator<<(ostream &out, const Square &rhs) {
  rhs.print(out);
  return out;
}

int main() {
  vector<Square> v = {Square{3.0}, Square{2.0}, Square{2.5}};
  cout << "Largest Square: " << findMax(v) << endl;

  return 0;
}
```
1.23演示了一个类类型的例子。实现了对Comparable要求的功能，同时阐释了运算符重载（operator overloading）。该Square类还提供了无参构造函数，operator=以及拷贝构造函数（均为默认）。这样就足以作为findMax中的Comparable对象来使用。  
1.23演示了一个最小的实现，并且阐释了为一个新的类类型提供输出函数而广泛使用的模式。该模式提供一个print的public成员函数，该函数接受ostream对象作为参数。此后这个print函数可以被一个全局的、非类类型的函数operator<<调用，函数operator<<接受一个ostream对象和一个将要输出的对象。
## 1.6.4 函数对象
模板有一个重要的局限：比如findMax，只对定义了operator<函数的对象有效。这个operator<是模板用来作为比较判断的基础的。在许多情况下，这种处理不可行。  
例如，假设Rectangle类将实现operator<运算，即使实现了，所含有的比较方法也许不一定是情景需要的。比如2\*10矩形和5\*5矩形谁更大呢？答案可以根据长度或面积决定。  
例如，假设需要找出字符串数组中最大的字符串（以字典序位于最后者），那么默认的operator<不能忽略字符的大小写区别，这将使得'Z'位于'a'之前。  
例如，有一个指向对象的指针数组。使用继承特性的高级C++程序中经常出现这种情况。  

解决办法是重写findMax函数来接受两个参数：一个是对象的数组，另一个解释如何决定operator<的判定。数组对象不再知道如何比较它们自己，这个信息完全从数组的对象中分离了。  

一种将函数作为参数传递的方法是：可定义没有数据、只有一个函数的类，将该类的一个对象作为参数传递。实际上是通过把函数放入一个对象之内来传递它。这个对象通常被称为函数对象（function object）。  
```cpp
#include <cstring>
#include <iostream>
#include <string>
#include <vector>
using namespace std;
// 1.24 使用函数对象作为findMax的第二个参数的最简单思路
template <typename Object, typename Comparator>
const Object &findMax(const vector<Object> &arr, Comparator cmp) {
  int maxIndex = 0;

  for (int i = 1; i < arr.size(); i++) {
    if (cmp.isLessThan(arr[maxIndex], arr[i]))
      maxIndex = i;
  }

  return arr[maxIndex];
}
class CaseInsensitiveCompare {
public:
  bool isLessThan(const string &lhs, const string &rhs) const {
    return _stricmp(lhs.c_str(), rhs.c_str()) < 0;
  }
};

int main() {
  vector<string> arr = {"ZEBRA", "alligator", "crocodile"};
  cout << findMax(arr, CaseInsensitiveCompare{}) << endl;

  return 0;
}
```
1.24展示函数对象的最简单实现。findMax接受的第2个参数是一个泛型类型。为使findMax模板成功展开，这个泛型类型必须有一个isLessThan成员函数，它需要第一个泛型类型（Object）的两个参数，返回一个bool值。  
C++函数对象使用这种基本思路来实现，但是将会用到一个奇特的语法（此处无展示）。  
首先，不是使用有名字的函数，而是使用运算符重载：不是使用isLessThan方法，而是使用operator()。  
其次，当调用operator()时，cmp.operator()(x, y)可以简写为cmp(x, y)。这看起来像是函数调用，因此operator()被称为函数调用操作符（function call operator）。结果，将参数名cmp可以改成更有意义的isLessThan，调用方法则为isLessThan(x, y)。  
再次，可提供一个不用函数对象就能工作的findMax版本。它的实现使用了标准库函数对象模板less（定义于头文件functional）来生成一个强制使用正常默认顺序的函数对象。  
1.25演示使用更为典型的、有些神秘的C++风格的实现。
```cpp
// 1.25 使用一个C++风格函数对象，用到findMax的第2个版本
template <typename Object, typename Comparator>
const Object &findMax(const vector<Object> &arr, Comparator isLessThan) {
  int maxIndex = 0;
  for (int i = 1; i < arr.size(); i++) {
    if (isLessThan(arr[maxIndex], arr[i]))
      maxIndex = i;
  }
  return arr[maxIndex];
}

#include <functional>
template <typename Object> const Object &findMax(const vector<Object> &arr) {
  return findMax(arr, less<Object>{});
}

class CaseInsensitiveCompare {
public:
  bool operator()(const string &lhs, const string &rhs) const {
    return _stricmp(lhs.c_str(), rhs.c_str()) < 0;
  }
};

int main() {
  vector<string> arr = {"ZEBRA", "alligator", "crocodile"};

  cout << findMax(arr, CaseInsensitiveCompare{}) << endl;
  cout << findMax(arr) << endl;

  return 0;
}
```
先后输出ZEBRA 和 crocodile。
## 1.6.5 类模板的分离式编译