# 模板
本书将描述类型无关的算法和数据结构，也称为泛型算法（generic algorithm）。本节描述泛型算法如何使用模板（template）编写。
## 1.6.1 函数模板（function template）
函数模板是可以变成一个函数的型式。1.19阐释函数模板findMax。  
```cpp
// 1.19 findMax函数模板
// 返回数组a中的最大项
// 假设a.size()>0
// 可比较的对象必须提供operator<和operator=
template <typename Comparable>
const Comparable &findMax(const vector<Comparable> &a) {
  int maxIndex = 0;
  for (int i = 1; i < a.size(); i++)
    if (a[maxIndex] < a[i])
      maxIndex = i;
  return a[maxIndex];
}
```
template声明指出，Comparable是一个模板参数，可被任何类型替代生成一个函数。例如，使用vector\<string\>作为参数对findMax进行调用，那么通过用string代替Comparable生成一个函数。
```cpp
// 1.20 findMax函数模板的使用
int main() {
  vector<int> v1(37);
  vector<double> v2(40);
  vector<string> v3(80);
  vector<IntCell> v4(75);

  cout << findMax(v1) << endl;
  cout << findMax(v2) << endl;
  cout << findMax(v3) << endl;
  cout << findMax(v4) << endl; // invalid: operator< undifined

  return 0;
}
```
1.20解释函数模板在需要时可自动展开。每个新类型的展开都会产生附加的代码，当其发生在大项目中时，就称为代码膨胀（code bloat）。   
习惯上在任何模板之前都要安排一些注释，解释关于模板参数都有哪些假设，包括关于需要一些什么类型的构造函数。  
模板参数可以假设为任意的类类型，因此在决定参数传递和返回传递时，应该假设模板参数不是基本类型。这就是采用常量引用返回的原因。  

存在许多神秘法则处理函数模板。大部分问题出在模板不能为参数提供准确匹配但是（通过隐式类型转换）接近它的时候。必须有一些方法解决歧义问题，而相关规则十分复杂。  
- 如果存在一个非模板和模板都匹配，那么优先匹配非模板。  
- 如果出现两个同等近似程度的匹配，那么代码非法并且编译程序将显示二义性。
## 1.6.2 类模板
