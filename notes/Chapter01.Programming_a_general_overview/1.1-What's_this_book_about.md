# 本书讨论的内容
**选择问题（selection problem）**  
设有一组N个数，要确定其中第k个最大者。  

- 一种直观解法是，将N个数读入一个数组中，再通过某种简单的算法比如冒泡排序（bubble sort），以递减顺序将数组排序，然后返回位置k上的元素。  

- 稍微好一点的算法可以先把前k个元素读入数组并以递减顺序排序。然后将剩下的元素逐个读入。当新元素被读到时，如果它小于数组中的第k个元素，则将其忽略，否则将其放到数组中的正确位置上，同时将原数组中的最后一个元素挤出数组。当算法终止时，第k个位置上的元素作为答案返回。  

这两个算法不能看作是好的算法，对于大量数据的计算，这两种算法完全不切实际。第七章将介绍一种能迅速得到结果的算法。  

**字谜游戏（word puzzle）**  
输入由一些字母构成的二维数组和一个单词表组成。目标是要找出字谜中的单词，这些单词可能是水平、垂直或对角线方向上放置的。  
| |1|2|3|4|    
|-|-|-|-|-|
|1|t|h|i|s|
|2|w|a|t|s|
|3|o|a|h|g|
|4|f|g|d|t|  

比如单词this从（1,1）到（1,4），方向为水平方向    

同样有两种直观的算法来求解这个问题。  

- 对单词表中的每个单词，检查每一个有序三元组（行，列，方向），验证是否有单词存在。这将需要大量嵌套的for循环。  
 
- 对于每一个尚未越出边缘的有序四元组（行，列，方向，字符数），可以检测是否所指的单词在单词表中。这同样需要大量嵌套的for循环。如果任意单词中的最大字符数已知，这将有助于减少一点时间。   

这两个算法也不能看作是好的算法。求解大量数据将耗费极长的时间。  

>一个重要的观念是，在许多问题中只写出一个工作的程序并不够。如果这个程序在大数据集上运行，那么运行时间就成了重要的问题。