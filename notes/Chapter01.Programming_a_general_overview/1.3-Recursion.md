# 递归简论  
一个用其自身来定义的函数称为是递归的（recursive）。  

定义一个函数f，满足f(0)=0, f(x)=2f(x-1)+x^2。
```cpp
int f(int x) {
  if (x == 0)
    return 0;
  else
    return 2 * f(x - 1) + x * x;
}
```  
递归方法若无基准情形则是毫无意义的。若使用该递归函数计算负值，则无法到达基准情形，无法得出结果。  

**递归与循环推理（circular logic）**  
虽然定义函数使用的是函数本身，但是并没有使用函数本身定义该函数的一个特定实例。比如，通过f(5)得到f(5)的值才是循环的。  

递归调用将持续调用直到基准情形出现。  

```cpp
int bad(int n) {
  if (n == 0)
    return 0;
  else
    return bad(n / 3 + 1) + n - 1;
}
```
该函数中，将bad(1)定义为bad(1)。计算机将反复调用bad(1)，最终内存空间被占满，程序崩溃。



>**打印输出整数**   
设有一个正整数n，需要将其打印出来。例程名称为printOut(n)。假设仅有的现成I/O例程printDigit()仅处理单个数字并将其输出到终端。  
> 
>使用递归解决该问题。  
>
>比如打印76234，需要先打印7623，再打印出4。要打印7623，就需要先打印762，再打印出3。  
除此之外，需要保证程序不是循环不止的。定义一个基准情形。如果0<=n<10，则基准情形就是printOut(n)。  
于是，printOut(n)对每一个从0到9的正整数定义，而更大的正整数则用较小的正整数定义。  
>```cpp
>void printDigit(int num);
>void printOut(int n) {
>  if (n >= 10)
>    printOut(n / 10);
>  else
>    printDigit(n % 10);
>}
>```
编写递归例程的四条基本法则：  
1. 基准情形 base cases  
必须有某些基准的情形，它们不用递归就能求解。
2. 要有进展 making progress  
递归调用必须总能朝着一个基准情形进展。
3. 设计法则 design rule  
假设所有的递归调用都能运行。
4. 合成效益法则 compound interest rule  
求解一个问题的同一实例时，切勿在不同的递归调用中做重复性的工作。  

*2026/1/9 23:40*