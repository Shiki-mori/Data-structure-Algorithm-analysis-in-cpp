# C++类  
所有的数据结构都将是存储数据的对象。它们还将提供处理这些数据的函数。在C++中，这是通过类来完成的。  
## 1.4.1 基本的class语法
类由成员（members）组成。这些成员可以是数据，也可以是函数，此时的函数叫作成员函数。  
类的每一个实例都是一个对象（object）。成员函数用于处理对象，成员函数也常常被叫作方法（method）。  
```cpp
// 一个IntCell类的完整声明（模拟整数内存单元）
class IntCell {
public:
  IntCell() { storedValue = 0; }
  IntCell(int initialValue) { storedValue = initialValue; }
  int read() { return storedValue; }
  void write(int x) { storedValue = x; }

private:
  int storedValue;
};
```

*2026/1/9 23:53*

## 1.4.2 构造函数的附加语法和访问函数
```cpp
class IntCell {
public:
  explicit IntCell(int initialValue = 0) : storedValue{initialValue} {}
  int read() const { return storedValue; }
  void write(int x) { storedValue = x; }

private:
  int storedValue;
};
```
这是一个经过修订的类，发生了四处变化。  
- **默认参数 default parameter**  
仍然定义两个IntCell构造函数。一个构造函数接收参数initialValue，另一个则是无参构造函数，是隐式的。单参数构造函数是可选的。 
默认参数可用于任何函数，但是最常见的是用在构造函数上。  
- **初始化表列 initialization list**  
IntCell构造函数在其函数体前使用了初始化表列，直接将数据成员初始化。  
对于数据成员是类类型其初始化过程非常复杂的情况，使用初始化表列更加节省时间。  
有些情况下，这是必需的。例如，数据成员为const型，那么该数据成员的值只能在初始化表列中被初始化。如果数据成员本身就是类类型，而该类型又没有0作为参数的构造函数，那么这个成员必须在初始化表列中被初始化。    
本例使用`:storedValue{initialValue}{}`  
而不是传统的`:storedValue(initialValue){}`  
使用{}代替()在C++11中是新规定。一般来说，在任何能够初始化的地方都可使用花括号将初始化括起来。（一个重要例外是1.4.4中的向量）  
- **explicit 构造函数**  
IntCell构造函数是explicit型的。 我们应该使所有的单参数构造函数为explicit的，以避免后台类型转换。否则会有些宽松的法则允许不带显示强制转换操作的类型转换。这会破坏强类型化（strong typing）并可能导致一些难以发现的故障。比如：
```cpp
IntCell obj;
obj = 3;
```
这段代码中的赋值语句不应该被编译。应该调用obj的write方法来执行相应的操作。但是C++有一些宽松法则。单参数构造函数将定义一个隐式类型转换（implicit type conversion），在隐式类型转换中创建一个临时对象，这个对象使得赋值（或函数参数）兼容。此时编译器将把`obj = 3;` 转换成
```cpp
IntCell temporary = 3;
obj = temporary;
```
temporary 的构建可以通过使用单参数构造函数完成。explicit的使用说明，单参数构造函数不能用于生成显式的temporary。于是编译器将正确地指出这种类型不匹配的问题。  
- **常成员函数**  
访问函数（accessor）：检查但不改变其对象状态的成员函数  
修改函数（mutator）：改变对象状态的成员函数  
C++中可以把每个函数标记为访问函数或修改函数。默认情况下所有函数都是修改函数。要使得成员函数称为访问函数，必须在加上关键字const。  
const可以以许多不同含义使用。函数声明在3中环境下可以使用const，只有const用于封闭的圆括号之后才表示函数是访问函数。  
## 1.4.3 接口与实现的分离
C++中将类接口和其实现分开更常见。接口列出类及其成员，实现提供函数的实现。  
```cpp
//1.7 头文件IntCell.h中的IntCell类接口
#ifndef IntCell_H
#define IntCell_H
class IntCell {
public:
  explicit IntCell(int initialValue = 0);
  int read() const;
  void write(int x);

private:
  int storedValue;
};
#endif

//1.8 文件IntCell.cpp中的IntCell类实现
#include "IntCell.h"
IntCell::IntCell(int initialValue) : storedValue{initialValue} {}
int IntCell::read() const { return storedValue; }
void IntCell::write(int x) { storedValue = x; }

// 1.9 文件TestIntCell，使用了IntCell类
#include "IntCell.h"
#include <iostream>

using namespace std;

int main() {
  IntCell m;
  m.write(5);
  cout << "Cell contents: " << m.read() << endl;

  return 0;
}
```
该例程中的一些要点：  
- **预处理命令**  
典型情况下，接口放在.h头文件中。需要接口知识的源代码必须要 #include 这个接口文件。  
复杂的项目中可能会有一些包含其他文件的文件，编译一个文件的过程中存在着一个接口可能被读两次的危险，这可能非法。为防止这种情况，当类接口被读入时每一个头文件都要使用预处理程序定义一个符号：  
`#ifndef IntCell_H`  
`#define IntCell_H`  
符号 IntCell_H 不应该出现在任何其他文件中，通常这个符号名都是由文件名来构建的。  
接口文件的第一行检测这个符号是否未定义，如果是，就可以处理该文件。否则不对文件处理，跳到#endif，因为这个文件已经被读过了。  
- **作用域解析运算符**  
在通常以.cpp, .cc 或 .C 结尾的实现文件中，每个成员函数必须与它所在的类关联。否则，该函数就要被假设是全局范围的，这会导致大量错误。::称为作用域解析运算符，Classname::member  
- **特征必须完全匹配**  
被实现的成员函数的特征必须完全匹配类接口中列出的特征。但是一些默认的参数只有在接口中被指定，在实现中是省略的。  
- **对象的声明同于基本类型**  
传统C++中，声明对象的方法就像声明一个基本类型。  
`IntCell obj2();`被判定为一个返回类型为IntCell类的函数。  
合法使用（C++11）：  
`IntCell obj1;  //使用无参构造函数`   
`IntCell obj2{12};`  
`IntCell obj3{};  //使用无参构造函数`  
  
   
**2026/1/10 22:46**

## 1.4.4 vector类和string类
C++标准定义了两个类：vector类和string类。  
vector用来代替C++数组。内置C++数组的问题在于，其行为不同于第一类对象（first-class object）。例如，数组不能使用=来复制；数组不记忆它能存储多少项；其下标运算符不检查下标是否合法。内置的字符串就是一个字符数组，因此妨碍它再添加一些字符的操作，例如不能使用==来比较字符串。  

STL（标准模板库）中的vector和string类把数组和串处理成第一类对象。vector对象知道它本身的大小。string对象可以通过==、<等运算符比较。均可使用=来复制。  
应尽可能避免使用内置的C++数组和字符串。  

**vector**  
以下程序创建一个vector对象，存储100个完全平方数并将其输出。
```cpp
//1.10 使用vector类：存储100个平方数并输出
#include <iostream>
#include <vector>
using namespace std;

int main() {
  vector<int> squares(100);

  for (int i = 0; i < squares.size(); ++i)
    squares[i] = i * i;

  for (int i = 0; i < squares.size(); ++i)
    cout << i << " " << squares[i] << endl;

  return 0;
}
```
这里的size是方法，返回vector对象的大小。许多情况下，vector对象的初始大小为0，随着需要而增长。  

C++数组的初始化：  
`int daysmonth[] = {31,28,31};`  
但是该语法对vector不成立。传统C++中，vector对象要么初始大小为0，要么可能指定一个大小。比如：  
```cpp
vector<int> daysmonth(12);
daysmonth[0] = 31;
daysmonth[1] = 28;
daysmonth[2] = 31;
```
C++11调整了该问题。允许：  
```cpp
vector<int> daysmonth = {31, 28, 31};
vector<int> daysmonth {31, 28, 31};
```
由此产生歧义：  
```cpp
vector<int> month {12};
```
不能得知这是大小为12的对象还是位置0上的元素为12的对象。C++11给了初始化表列优先权，因此这是一个在位置0上的元素为12，大小为1的vector对象。如果需要初始化vector的大小，则必须使用传统C++中的圆括号( )。  

**string**  
string拥有比较两个字符串状态的所有关系运算符和相等运算符。string的length方法返回字符串的长度。  
在数组或vector这类集合中，依序访问每一个元素的格式是常用操作，使用数组下标来操作不能清楚地表示出这种特色。  
C++11因此添加了范围for语句（range for）的概念。  
```cpp
int sum = 0;
for(int i = 0; i < squares.size(); ++i)
  sum += squares[i];
```
上述语句可改写为：
```cpp
int sum = 0;
for(int x: squares)
  sum += x;
```
很多情况下，范围for语句内的类型声明不必要。x将根据squares对象的类型进行适配。因此C++11允许使用保留字 auto 来表示编译器将会自动推断出相应的类型：  
```cpp
int sum = 0;
for(auto x: squares)
  sum += x;
```
只要每一项都被依次访问且不需要下标，则范围for循环（range for loop）就适用。程序1.10中的两个for循环不能改写成范围for循环，因为下标i还被用于其他计算。  
范围for循环只允许对项的查看。

**2026/1/11 19:38**