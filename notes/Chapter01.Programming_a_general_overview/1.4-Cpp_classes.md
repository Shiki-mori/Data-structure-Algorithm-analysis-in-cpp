# C++类  
所有的数据结构都将是存储数据的对象。它们还将提供处理这些数据的函数。在C++中，这是通过类来完成的。  
## 1.4.1 基本的class语法
类由成员（members）组成。这些成员可以是数据，也可以是函数，此时的函数叫作成员函数。  
类的每一个实例都是一个对象（object）。成员函数用于处理对象，成员函数也常常被叫作方法（method）。  
```cpp
// 一个IntCell类的完整声明（模拟整数内存单元）
class IntCell {
public:
  IntCell() { storedValue = 0; }
  IntCell(int initialValue) { storedValue = initialValue; }
  int read() { return storedValue; }
  void write(int x) { storedValue = x; }

private:
  int storedValue;
};
```

*2026/1/9 23:53*

## 1.4.2 构造函数的附加语法和访问函数
```cpp
class IntCell {
public:
  explicit IntCell(int initialValue = 0) : storedValue{initialValue} {}
  int read() const { return storedValue; }
  void write(int x) { storedValue = x; }

private:
  int storedValue;
};
```
这是一个经过修订的类，发生了四处变化。  
- **默认参数 default parameter**  
仍然定义两个IntCell构造函数。一个构造函数接收参数initialValue，另一个则是无参构造函数，是隐式的。单参数构造函数是可选的。 
默认参数可用于任何函数，但是最常见的是用在构造函数上。  
- **初始化表列 initialization list**  
IntCell构造函数在其函数体前使用了初始化表列，直接将数据成员初始化。  
对于数据成员是类类型其初始化过程非常复杂的情况，使用初始化表列更加节省时间。  
有些情况下，这是必需的。例如，数据成员为const型，那么该数据成员的值只能在初始化表列中被初始化。如果数据成员本身就是类类型，而该类型又没有0作为参数的构造函数，那么这个成员必须在初始化表列中被初始化。    
本例使用`:storedValue{initialValue}{}`  
而不是传统的`:storedValue(initialValue){}`  
使用{}代替()在C++11中是新规定。一般来说，在任何能够初始化的地方都可使用花括号将初始化括起来。（一个重要例外是1.4.4中的向量）  
- **explicit 构造函数**  
IntCell构造函数是explicit型的。 我们应该使所有的单参数构造函数为explicit的，以避免后台类型转换。否则会有些宽松的法则允许不带显示强制转换操作的类型转换。这会破坏强类型化（strong typing）并可能导致一些难以发现的故障。比如：
```cpp
IntCell obj;
obj = 3;
```
这段代码中的赋值语句不应该被编译。应该调用obj的write方法来执行相应的操作。但是C++有一些宽松法则。单参数构造函数将定义一个隐式类型转换（implicit type conversion），在隐式类型转换中创建一个临时对象，这个对象使得赋值（或函数参数）兼容。此时编译器将把`obj = 3;` 转换成
```cpp
IntCell temporary = 3;
obj = temporary;
```
temporary 的构建可以通过使用单参数构造函数完成。explicit的使用说明，单参数构造函数不能用于生成显式的temporary。于是编译器将正确地指出这种类型不匹配的问题。  
- **常成员函数**  
访问函数（accessor）：检查但不改变其对象状态的成员函数  
修改函数（mutator）：改变对象状态的成员函数  
C++中可以把每个函数标记为访问函数或修改函数。默认情况下所有函数都是修改函数。要使得成员函数称为访问函数，必须在加上关键字const。  
const可以以许多不同含义使用。函数声明在3中环境下可以使用const，只有const用于封闭的圆括号之后才表示函数是访问函数。  
## 1.4.3 接口与实现的分离
C++中将类接口和其实现分开更常见。接口列出类及其成员，实现提供函数的实现。  
```cpp
//1.7 头文件IntCell.h中的IntCell类接口
#ifndef IntCell_H
#define IntCell_H
class IntCell {
public:
  explicit IntCell(int initialValue = 0);
  int read() const;
  void write(int x);

private:
  int storedValue;
};
#endif

//1.8 文件IntCell.cpp中的IntCell类实现
#include "IntCell.h"
IntCell::IntCell(int initialValue) : storedValue{initialValue} {}
int IntCell::read() const { return storedValue; }
void IntCell::write(int x) { storedValue = x; }

// 1.9 文件TestIntCell，使用了IntCell类
#include "IntCell.h"
#include <iostream>

using namespace std;

int main() {
  IntCell m;
  m.write(5);
  cout << "Cell contents: " << m.read() << endl;

  return 0;
}
```
该例程中的一些要点：  
- **预处理命令**  
典型情况下，接口放在.h头文件中。需要接口知识的源代码必须要 #include 这个接口文件。  
复杂的项目中可能会有一些包含其他文件的文件，编译一个文件的过程中存在着一个接口可能被读两次的危险，这可能非法。为防止这种情况，当类接口被读入时每一个头文件都要使用预处理程序定义一个符号：  
`#ifndef IntCell_H`  
`#define IntCell_H`  
符号 IntCell_H 不应该出现在任何其他文件中，通常这个符号名都是由文件名来构建的。  
接口文件的第一行检测这个符号是否未定义，如果是，就可以处理该文件。否则不对文件处理，跳到#endif，因为这个文件已经被读过了。  
- **作用域解析运算符**  
在通常以.cpp, .cc 或 .C 结尾的实现文件中，每个成员函数必须与它所在的类关联。否则，该函数就要被假设是全局范围的，这会导致大量错误。::称为作用域解析运算符，Classname::member  
- **特征必须完全匹配**  
被实现的成员函数的特征必须完全匹配类接口中列出的特征。但是一些默认的参数只有在接口中被指定，在实现中是省略的。  
- **对象的声明同于基本类型**  
传统C++中，声明对象的方法就像声明一个基本类型。  
`IntCell obj2();`被判定为一个返回类型为IntCell类的函数。  
合法使用（C++11）：  
`IntCell obj1;  //使用无参构造函数`   
`IntCell obj2{12};`  
`IntCell obj3{};  //使用无参构造函数`  
  
   
**2026/1/10 22:46**

## 1.4.4 vector类和string类